'use strict';
const Simulator = require('./simulator');
const Device = require('./device');
const Sensor = require('./sensor');
const bunyan = require('bunyan');
const Helper = require('../helper/helper');
const commandLineArgs = require('command-line-args');
const Errors = require('http-errors');

const simulatorName = 'device-simulator';
const port = 8081;

const logger = bunyan.createLogger({
  'name': simulatorName,
  serializers: bunyan.stdSerializers
});

const deviceUrl = '/api/_/device';

const deviceOptions = {
  logger: logger,
  url: deviceUrl,
  port: port
};

class SimulatorMain {
  async createDevice(options) {
    let data;
    deviceOptions.name = options.name;
    let device = new Device(deviceOptions);
  
    try {
      device.setSensors(this.parseSensorCla(options.sensor));
      device.updateDeviceParams();
      data = await device.create();
    } catch (err) {
      logger.error('Failed to crate device Error:', err);
      return;
    }
    
    logger.info('Device created, id: ', data.id);
    return device;
  }
  
  /**
   * Delete device with id
   * @param {Object} options  - {id: uuid of device}
   */
  async deleteDevice(options) {
    let data;
    let device = new Device({
      logger: logger,
      url: '/api/_/device',
      port: port
    });
  
    try {
      device.setId(options.id);
      data = await device.delete();
    } catch (err) {
      logger.error('Failed to delete device with id', options.id, 'Error:', err);
      throw err;
    }
    
    logger.info('Device deleted, id: ', options.id);
    return device;
  }
  
  /**
   * Update device
   */
  async updateDevice(options) {
    let data;
    let device = new Device({
      logger: logger,
      url: '/api/_/device',
      port: port
    });
  
    try {
      device.setId(options.id);
      device.setSensors(this.parseSensorCla(options.sensor));
      device.updateDeviceParams();
      data = await device.update(options);
    } catch (err) {
      logger.error('Failed to update device with id', options.id, 'Error:', err);
      throw err;
    }
    
    logger.info('Device updated, id: ', options.id);
    return device;
  }
  
  /**
   * Returns all devices in dB;
   * @param {Number} id device Id, returns device with given id
   */
  async getDevice(id) {
    let device;
    const options = {
      port: port,
      hostname: 'localhost',
      url: id ? `${deviceUrl}/${id}`: deviceUrl,
      method: 'GET',
      logger: logger,
      successCode: 200
    };
  
    try {
      device = await Helper.sendRequest(options);
    } catch (err) {
      logger.error('Failed to get devices', err);
      throw new Errors.InternalServerError();
    }
  
    logger.info('Retrieved device information');
    return device;
  };

  async cleanDb() {
    let result;
    const options = {
      port: port,
      hostname: 'localhost',
      url: deviceUrl,
      method: 'DELETE',
      logger: logger,
      successCode: 200
    };
  
    try {
      result = await Helper.sendRequest(options);
    } catch (err) {
      logger.error('Failed to clean db', err);
      throw new Errors.InternalServerError();
    }
  
    logger.info('Removed all devices from db');
    return result;
  }
  
  /**
   * Parse sensor cla 
   * @param {Object} cla  - sensor data from cla
   */
  parseSensorCla(data) {
    let sensorArray = data.map((item) => {  
      item = item.split(':');
      return new Sensor({
        name: item[0],
        value: item[1],
        unit: item[2]
      });
    });
  
    return sensorArray;
  }
  
  /**
   * 
   * @param {Array} Array of devices 
   */
  async simulate(deviceList) {
    const simulator = new Simulator({
      logger:logger,
      port:port
    });
  
    simulator.createLocalDevices(deviceList);
    try {
      // skip device creation
      await simulator.start(true);
    } catch(err) {
      logger.error('Failed to start devices');
      throw err;
      return
    }
    logger.info('All device started');
  }

  async autoSimulate() {
    const maxDevices = 5;
    const maxSensors = 5;

    const simulator = new Simulator({
      logger: logger,
      port: port
    });

    logger.info('Auto generating', maxDevices, 'devices with maximum of ', maxSensors, 'sensors');
    try {
      await simulator.autoGenerateDevices(maxDevices, maxSensors);
    } catch(err) {
      logger.error('Failed to auto generate devics');
    }

    logger.info('Device generation complete');
    logger.info('Starting devices');
    try {
      // create device before start
      await simulator.start();
    } catch (err) {
      logger.error('Failed to start devices', err);
      throw err;
    }
  }
}


const optionDefinitions = [
  { name: 'create', alias: 'c', type: Boolean },
  { name: 'name', alias: 'n', type: String},
  { name: 'sensor', alias: 's', type: String, multiple: true},
  { name: 'update', alias: 'u', type:Boolean},
  { name: 'id', alias: 'i', type:String},
  { name: 'delete', alias: 'd', type:Boolean},
  { name: 'get', alias: 'g', type:Boolean},
  { name: 'start', type:Boolean},
  { name: 'auto', type:Boolean},
  { name: 'clean', type:Boolean},
  { name: 'help', alis: 'h', type:Boolean}
];

function printHelp() {
  let msg = `node index.js [opts] [args]
    --create  : Creates a device, will require '--name' & '--sensor' parameters
    --name    : Device name
    --sensor  : Sensor parameters, takes multiple values, e.g: name1:value1:unit1 name2:value2:unit2
    --update  : Updates device paramter, will require '--id' & '--sensor' parameter
    --id      : Device id. A new id will be assigned if not provided
    --delete  : Delete device, will require '--id' parameter
    --get     : Returns all devices if '--id' parameter is not provided
    --start   : Starts simulation with existing devices in dB
    --auto    : Auto generates 5 devices with maximum of 5 sensors each. (Recommended to use for quick check)
    --clean   : Cleans database
    --help    : Prints help
  `
  console.log(msg);
}

if (require.main === module) {
  let cla;
  const simulator = new SimulatorMain();
  try {
    cla = commandLineArgs(optionDefinitions);
  } catch(err) {
    logger.error('Failed to extract command line options', err);
    process.exit(1);
  }

  if (cla.help) {
    printHelp();
    return;
  }

  if (cla.create) {
    if (!cla.sensor) {
      logger.error('Create device requires sensor data', new Errors.BadRequest());
      return;
    }

    simulator.createDevice(cla);
    return;
  }

  if (cla.update) {
    if (!cla.sensor) {
      logger.error('Update device requires sensor data', new Errors.BadRequest());
      return;
    }

    if (!cla.id) {
      logger.error('Update device requires id', new Errors.BadRequest());
      return;
    }
    
    simulator.updateDevice(cla);
    return;
  }

  if (cla.delete) {
    if (!cla.id) {
      logger.error('Delete device function requires id', new Errors.BadRequest());
      return;
    }

    simulator.deleteDevice(cla);
    return;
  }

  if (cla.clean) {
    simulator.cleanDb()
      .catch((err) => logger.error('Failed to clean db', err));
  }

  if (cla.get) {
    simulator.getDevice(cla.id)
      .then((device) => console.log(JSON.stringify(device, null, ' ')))
      .catch((err) => logger.error(err));
    return;
  }

  if (cla.auto) {
    simulator.autoSimulate()
      .catch((err) => logger.error('Failed to auto simulate', err));
  }

  if (cla.start) {
    simulator.getDevice()
      .then(simulator.simulate)
      .catch((err) => logger.error('Failed to simulate', err));
  }
}

module.exports = SimulatorMain;